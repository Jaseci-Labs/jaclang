---
sidebar_position: 4
description: Scratchpad for ideas and thoughts
title: Scratchpad
---

Brainstorm Code Snippet

```jac
walker init {
	
can ..

std.out()
with entry {}
std.log()
nodeblock1 {}

nodeblock1, n2 {}

n2 {}

}

walker init {
has ..
can ..

can name with * entry {}
can myblock with mynode entry {}
can myblock2 with mynode entry {}
can name with * exit {}

}

walker init2:init1 {

can myblock with mynode_sub {}

}


node whatever {
}

py whatever2 {

import imp; 
a =5;

def func
class blha

}

py whatever2 {

import imp;
a =5;


def func
class blha

}

py w2 {
import w1
import pandas
}



cpy whateverc {
}

walker init {

   pak = whatever2.func;
   a=pak.a
	nodea.a=pak.a

   pak.imp()
   pak.blha.fun()

}

class Walker()
{
   Abilities

 	def take(node)
	def run
}


class init(Walker):
  def __init__



walker init {
   take -->;
}

node simple {
has 
has 
can 
}

class simple(Node) {
  addAbility(can); 
}

class init(Walker):
   def run:
      self.take(self.outbout_nodes());

Quick next steps
* build in sly
* trans pile
* create proper super set, library first implementation
```